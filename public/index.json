[
  {
    "content": "Setup AWS CLI Follow below steps for installation of AWS CLI on Windows Operating System\nVerify Python installation: AWS CLI requires Python to be installed on your Windows laptop. Open the Command Prompt by searching for “Command Prompt” in the Windows Start menu.\nThen, type the following command and press Enter to check if Python is installed:\npython --version If Python is not installed, download and install the latest version of Python from the official website (https://www.python.org/downloads/). Make sure to select the option to add Python to the system PATH during the installation process.\nOpen the Command Prompt: Open the Command Prompt on your Windows laptop. You can do this by searching for “Command Prompt” in the Windows Start menu.\nInstall AWS CLI using pip: In the Command Prompt, run the following command to install AWS CLI using the Python package manager, pip:\npip install awscli This command will download and install the AWS CLI and its dependencies.\nVerify AWS CLI installation: After the installation is complete, you can verify if AWS CLI is installed correctly by running the following command in the Command Prompt:\naws --version If the installation was successful, it will display the version of AWS CLI installed on your system.\nConfigure AWS CLI: To use AWS CLI, you need to configure it with your AWS credentials. Run the following command in the Command Prompt:\naws configure This command will prompt you to enter your AWS Access Key ID, AWS Secret Access Key, default region, and default output format. You can obtain the Access Key ID and Secret Access Key from the AWS Management Console. The default region is the AWS region you want to interact with (e.g., “us-west-2” for US West (Oregon)). The default output format can be set to “json” or “text”.\nRef this link to get IAM User Access Key and Secret Access Key (http://localhost:56450/aws/iam/iam_keys/)\nOnce you have entered the required information, it will be stored in a configuration file on your system.\nThat’s it! You have successfully installed and configured AWS CLI on your Windows laptop.\nValidate AWS CLI installation using below command\naws s3 ls You can now use AWS CLI commands to interact with various AWS services from the Command Promp ",
    "description": "",
    "tags": null,
    "title": "Configure AWS CLI - Windows",
    "uri": "/terraform/cli_setup_windows/index.html"
  },
  {
    "content": "Setup AWS CLI To set up the AWS Command Line Interface (CLI) on a MacBook, you can follow these steps:\nInstall Python: AWS CLI requires Python to be installed on your MacBook. By default, macOS comes with a pre-installed version of Python. Open the Terminal application (you can find it in the “Utilities” folder within “Applications”) and run the following command to check if Python is installed: python --version If Python is not installed, you can download and install it from the official Python website (https://www.python.org/downloads/). It is recommended to install the latest stable version.\nInstall AWS CLI using pip: In the Terminal, run the following command to install AWS CLI using the Python package manager, pip: pip install awscli --upgrade --user This command will download and install the AWS CLI and its dependencies. The --upgrade flag ensures that you get the latest version of AWS CLI, and the --user flag installs it in the user’s directory.\nVerify AWS CLI installation: After the installation is complete, you can verify if AWS CLI is installed correctly by running the following command in the Terminal: aws --version If the installation was successful, it will display the version of AWS CLI installed on your system.\nConfigure AWS CLI: To use AWS CLI, you need to configure it with your AWS credentials. Run the following command in the Terminal: aws configure This command will prompt you to enter your AWS Access Key ID, AWS Secret Access Key, default region, and default output format. You can obtain the Access Key ID and Secret Access Key from the AWS Management Console. The default region is the AWS region you want to interact with (e.g., “us-west-2” for US West (Oregon)). The default output format can be set to “json” or “text”.\nOnce you have entered the required information, it will be stored in a configuration file on your system.\nValidate AWS CLI installation using below command aws s3 ls That’s it! You have successfully set up AWS CLI on your MacBook. You can now use AWS CLI commands to interact with various AWS services from the Terminal.\n",
    "description": "",
    "tags": null,
    "title": "Configure AWS CLI - Mac OS",
    "uri": "/terraform/cli_setup_macos/index.html"
  },
  {
    "content": "To install Terraform on a Windows system, you can follow these steps:\nDownload the Terraform binary:\nOpen a web browser and go to the Terraform website at https://www.terraform.io/downloads.html. Scroll down to the “Terraform Core” section and locate the Windows version. Click on the appropriate 64-bit or 32-bit download link depending on your system architecture. This will download a ZIP file containing the Terraform binary. Extract the Terraform binary:\nLocate the downloaded ZIP file, right-click on it, and select “Extract All” from the context menu. Choose the destination folder where you want to extract the contents of the ZIP file. Set up the PATH environment variable:\nOpen the Start menu and search for “Environment Variables”. Click on “Edit the system environment variables” to open the System Properties window. In the System Properties window, click on the “Environment Variables” button. In the “System variables” section, scroll down and find the “Path” variable. Select it and click on the “Edit” button. In the “Edit Environment Variable” window, click on the “New” button and enter the path to the directory where you extracted the Terraform binary. For example, if you extracted it to “C:\\terraform”, enter that path. Click “OK” to save the changes. Verify the installation:\nOpen a new Command Prompt window by searching for “Command Prompt” in the Start menu. Type terraform --version and press Enter. If Terraform is correctly installed and the PATH environment variable is set up correctly, it will display the version of Terraform installed on your system. That’s it! You have successfully installed Terraform on your Windows system. You can now use Terraform commands to manage your infrastructure as code. Remember to consult the Terraform documentation for further guidance on using Terraform and setting up your configurations.\n",
    "description": "",
    "tags": null,
    "title": "Configure Terraform - Windows",
    "uri": "/terraform/terraform_setup_windows/index.html"
  },
  {
    "content": "To install Terraform on macOS using Homebrew, you can follow these steps:\nOpen the Terminal application. You can find it in the “Utilities” folder within the “Applications” folder.\nInstall Homebrew (if not already installed): In the Terminal, paste the following command and press Enter:\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" This command will install Homebrew, a package manager for macOS.\nInstall Terraform: In the Terminal, run the following command to install Terraform using Homebrew: brew install terraform This command will download and install the latest version of Terraform from the Homebrew repository.\nVerify the installation: After the installation is complete, you can verify if Terraform is installed correctly by running the following command in the Terminal: terraform --version If the installation was successful, it will display the version of Terraform installed on your system.\nThat’s it! You have successfully installed Terraform on your macOS system using Homebrew. You can now use Terraform commands to manage your infrastructure as code. Make sure to consult the Terraform documentation for further guidance on using Terraform and setting up your configurations.\n",
    "description": "",
    "tags": null,
    "title": "Configure Terraform - Mac OS",
    "uri": "/terraform/terraform_setup_macos/index.html"
  },
  {
    "content": "Problem Statement : Setup EC2 instance using Terraform with below specifications. Region : Mumbai Subnet ID : subnet-6f19ee04 (AZ Name : ap-south-1a) Key Name : devops2022.pem Security Group : allow http port(Port -80) to everyone (0.0.0.0/0) User Data: #!/bin/bash yum update -y yum install -y httpd systemctl start httpd.service systemctl enable httpd.service echo \"Welcome to Terraform Demo!!!, I am $(hostname -f) hosted by Terraform\" \u003e /var/www/html/index.html Create first terraform code in VS Code as below provider \"aws\" { region = \"ap-south-1\" } resource \"aws_instance\" \"ec2_demo\" { ami = \"ami-079b5e5b3971bd10d\" instance_type = \"t2.micro\" tags = { Name = \"Created_By_Terraform\" } } Initiliaze terraform directory using below command terraform init terraform plan - Execute terraform plan terraform plan terraform apply - Execute terraform plan terrraform apply Validate newly created EC2 in AWS Console ",
    "description": "",
    "tags": null,
    "title": "Terraform Setup EC2 Instance",
    "uri": "/terraform/setup_ec2_terraform/index.html"
  },
  {
    "content": "Networking Concepts Concept Explanation Example IP Address A unique numerical label assigned to devices on a network, enabling communication between devices. 192.168.0.1 Subnet Mask A numeric code used with an IP address to determine the network and host portions of the address. 255.255.255.0 Gateway A network node or device that acts as an access point to connect one network to another, allowing communication between networks. Router: 192.168.0.254 DNS (Domain Name System) A system that translates domain names into IP addresses, enabling users to access websites using familiar domain names. Domain: www.example.comIP: 192.0.2.1 DHCP (Dynamic Host Configuration Protocol) A protocol that automatically assigns IP addresses and network configuration settings to devices on a network. DHCP Server: 192.168.0.100Assigned IP: 192.168.0.10 Firewall A network security device or software that monitors and controls incoming and outgoing network traffic based on predefined rules. Firewall: FortinetBlock incoming connections on port 22 Routing The process of selecting the best path for data packets to travel from a source device to a destination device across a network. Source IP: 192.168.0.1Destination IP: 10.0.0.1Router: 192.168.0.254Router: 10.0.0.254 TCP (Transmission Control Protocol) A reliable and connection-oriented protocol that provides error checking, sequencing, and flow control for data transmission. Sending an email over the internet using SMTP (Simple Mail Transfer Protocol) UDP (User Datagram Protocol) A lightweight and connectionless protocol that provides fast, but unreliable, data transmission without error checking or flow control. Video streaming or online gaming, where real-time data transmission is important This table provides an overview of various networking concepts, explaining their functions and providing examples. While the corresponding diagrams are omitted in this format, the explanations provide a clear understanding of each concept.\n",
    "description": "",
    "tags": null,
    "title": "Networking Conncept",
    "uri": "/basics-of-networking/networking_concepts/index.html"
  },
  {
    "content": " The command line interface to Terraform is via the terraform command, which accepts a variety of subcommands such as terraform init or terraform plan. terraform help : Terraform has a built-in help system that can be accessed from the command line for commands that you are not familiar with, or want to learn more about. You can get specific help for any specific command, use the -help option with the relevant subcommand. nilesh@Nileshs-MacBook-Air import-demo % terraform -help Usage: terraform [global options] \u003csubcommand\u003e [args] The available commands for execution are listed below. The primary workflow commands are given first, followed by less common or more advanced commands.\nMain commands: init Prepare your working directory for other commands validate Check whether the configuration is valid plan Show changes required by the current configuration apply Create or update infrastructure destroy Destroy previously-created infrastructure All other commands: console Try Terraform expressions at an interactive command prompt fmt Reformat your configuration in the standard style force-unlock Release a stuck lock on the current workspace get Install or upgrade remote Terraform modules graph Generate a Graphviz graph of the steps in an operation import Associate existing infrastructure with a Terraform resource login Obtain and save credentials for a remote host logout Remove locally-stored credentials for a remote host output Show output values from your root module providers Show the providers required for this configuration refresh Update the state to match remote systems show Show the current state or a saved plan state Advanced state management taint Mark a resource instance as not fully functional test Experimental support for module integration testing untaint Remove the 'tainted' state from a resource instance version Show the current Terraform version workspace Workspace management Global options (use these before the subcommand, if any): -chdir=DIR Switch to a different working directory before executing the given subcommand. -help Show this help output, or the help for a specified subcommand. -version An alias for the \"version\" subcommand. terraform init The terraform init command is used to initialise a working directory containing terraform configuration files. This is the first command that should be run after writing a new Terraform configuration or cloning an existing one from version control. It is safe to run this command multiple times. terraform init terraform plan The terraform plan command is used to create an execution plan. It will not modify things in infrastructure.Terraform performs a refresh, unless explicitly disabled, and then determines what actions are necessary to achieve the desired state specified in the configuration files.\nThis command is a convenient way to check whether the execution plan for a set of changes matches your expectations without making any changes to real resources or to the state.\nterraform plan Creates an execution plan (dry run) terraform plan -out=path save generated plan output as a file terraform plan -destroy Outputs a destroy plan terraform plan terraform apply The terraform apply command is used to apply the changes required to reach the desired state of the configuration. Terraform apply will also write data to the terraform.tfstate file. Once the application is completed, resources are immediately available.\nterraform apply’ : Executes changes to the actual environment terraform apply –auto-approve : Apply changes without being prompted to enter ”yes” terraform apply -refresh=true : Update the state for each resource prior to planning and applying terraform apply -input=false : Ask for input for variables if not directly set terraform apply -var ‘foo=bar’ : Set a variable in the Terraform configuration, can be used multiple times terraform apply -var-file=foo : Specify a file that contains key/value pairs for variable values terraform apply -target : Only apply/deploy changes to the targeted resource\nterraform apply terraform refresh The terraform refresh command reads the current settings from all managed remote objects and updates the Terraform state to match. This does not modify infrastructure but does modify the state file. terraform refresh terraform validate The terraform validate command validates the configuration files in a directory.Validate runs checks that verify whether a configuration is syntactically valid and thus primarily useful for general verification of reusable modules, including the correctness of attribute names and value types. nilesh@Nileshs-MacBook-Air ec2-demo % terraform validate Success! The configuration is valid. ```sh ### terraform graph - The terraform graph command is used to generate a visual representation of either a configuration or execution plan. The output is in the DOT format, which can be used by GraphViz to generate charts. ```sh terraform graph | dot -Tsvg \u003e graph.svg terraform fmt The terraform fmt command is used to rewrite Terraform configuration files to a canonical format and style. This command applies a subset of the Terraform language style conventions, along with other minor adjustments for readability. -recursive — Also process files in subdirectories. By default, only the given directory (or current directory) is processed.\nnilesh@Nileshs-MacBook-Air ec2-demo % terraform fmt terraform output The terraform output command is used to extract the value of an output variable from the state file. terraform output terraform show The terraform show command is used to provide human-readable output from a state or plan file.This can be used to inspect a plan to ensure that the planned operations are expected, or to inspect the current state as Terraform sees it. terraform show terraform taint The terraform taint command informs Terraform that a particular object has become degraded or damaged. Terraform represents this by marking the object as “tainted” in the Terraform state, and Terraform will propose to replace it in the next plan you create. terraform taint untaint If Terraform currently considers a particular object as tainted but you’ve determined that it’s actually functioning correctly and need not be replaced, you can use terraform untaint to remove the taint marker from that object. This command will not modify any real remote objects, but will modify the state in order to remove the tainted status.\nterraform untaint terraform replace For Terraform v0.15.2 and later, terraform recommend using the -replace option with terraform apply to force Terraform to replace an object even though there are no configuration changes that would require it.\nThe change will be reflected in the Terraform plan, letting you understand how it will affect your infrastructure before you take any externally-visible action.\nWhen you use terraform taint, other users could create a new plan against your tainted object before you can review the effects terraform taint aws_instance.web (mark resource as tainted and then we need to terraform apply) terraform version This command will print terraform version\nterraform — version terraform workspace The terraform workspace command is used to manage workspaces.\nThe terraform workspace new command is used to create a new workspace. The terraform workspace list command is used to list all existing workspaces. The terraform workspace show command is used to output the current workspace. The terraform workspace select command is used to choose a different workspace to use for further operations. The terraform workspace delete command is used to delete a workspace. ```sh terraform workspace list terraform workspace new dev terraform workspace list terraform workspace select dev terraform workspace delete dev terraform workspace select default terraform workspace delete dev terraform workspace show terraform import The terraform import command is used to import existing resources into Terraform. Import will find the existing resource from ID and import it into your Terraform state at the given ADDRESS. ADDRESS must be a valid resource address. Because any resource address is valid, the import command can import resources into modules as well as directly into the root of your state.\nUse Case : Suppose there is one ec2 instance which is already provisioned in AWS and now you want to to import that ec2 instance in terraform code.\nManually Created EC2 Instance in AWS\nExample : # Sample_Terraform_Code resource “aws_instance” “import_demo” { } nilesh@Nileshs-MacBook-Air import-demo % terraform init nilesh@Nileshs-MacBook-Air import-demo % terraform import ### terraform destroy - The terraform destroy command is used to destroy the terraform-managed infrastructure. Terraform destroy command is not the only command through which infrastructure can be destroyed.You can remove the resource block from the configuration and run terraform apply this way you can destroy the infrastructure. ```sh terraform destroy –auto-approve : Destroy/cleanup without being prompted to enter ”yes” terraform destroy -target : Only destroy the targeted resource and its dependencies terraform destory References : https://www.terraform.io/cli/commands ",
    "description": "",
    "tags": null,
    "title": "Terraform Commands",
    "uri": "/terraform/terraform_commands/index.html"
  },
  {
    "content": "Basics of Networking This section covers: - Terraform\n",
    "description": "",
    "tags": null,
    "title": "Basics of Networking",
    "uri": "/basics-of-networking/index.html"
  },
  {
    "content": "Terrafom Features This section covers: - Terraform\n",
    "description": "",
    "tags": null,
    "title": "Infra As Code Terraform",
    "uri": "/terraform/index.html"
  },
  {
    "content": "Terrafom Features This section covers: - AWS\n",
    "description": "",
    "tags": null,
    "title": "Cloud Computing AWS",
    "uri": "/aws/index.html"
  },
  {
    "content": "Networking Playlist Concept Explanation IP Address A unique numerical label assigned to devices on a network, enabling communication between devices. Subnet Mask A numeric code used with an IP address to determine the network and host portions of the address. Gateway A network node or device that acts as an access point to connect one network to another, allowing communication between networks. ",
    "description": "",
    "tags": null,
    "title": "Networking Playlist",
    "uri": "/basics-of-networking/playlist/index.html"
  },
  {
    "content": "OSI Model The OSI (Open Systems Interconnection) model is a conceptual framework that standardizes and defines the functions of a communication system or network. It helps in understanding how different components of a network interact and communicate with each other. The OSI model consists of seven layers, each serving a specific purpose and providing a set of services to the layer above it. The seven layers of the OSI model are: Certainly! Here’s an explanation of the OSI (Open Systems Interconnection) model in table format with examples:\nLayer Function Protocols/Examples Application Provides network services directly to user applications. HTTP, FTP, DNS, SMTP, Telnet Presentation Handles data translation, encryption, and compression to ensure compatibility between different systems. JPEG, MPEG, SSL/TLS Session Establishes, manages, and terminates communication sessions between applications. NetBIOS, SIP, NFS Transport Ensures reliable and transparent transfer of data segments between network hosts. TCP, UDP Network Routes and delivers data packets across different networks. IP, ICMP, OSPF, BGP Data Link Establishes and manages a reliable link between two directly connected nodes. Ethernet, Wi-Fi, PPP, HDLC, MAC Physical Transmits raw bitstream over the physical medium. Ethernet cables, fiber optic cables, radio waves Now, let’s provide examples for each layer:\nApplication Layer: HTTP (Hypertext Transfer Protocol) is used for web browsing, FTP (File Transfer Protocol) is used for file transfer, DNS (Domain Name System) is used for domain name resolution, and Telnet is used for remote login.\nPresentation Layer: JPEG (Joint Photographic Experts Group) is a file format for image compression, MPEG (Moving Picture Experts Group) is used for video and audio compression, and SSL/TLS (Secure Sockets Layer/Transport Layer Security) provides secure communication over the internet.\nSession Layer: NetBIOS (Network Basic Input/Output System) allows applications on different devices to establish sessions, SIP (Session Initiation Protocol) is used for establishing multimedia sessions, and NFS (Network File System) enables file sharing over a network.\nTransport Layer: TCP (Transmission Control Protocol) provides reliable, connection-oriented data delivery, while UDP (User Datagram Protocol) provides connectionless, unreliable data delivery.\nNetwork Layer: IP (Internet Protocol) handles the addressing and routing of data packets across networks, ICMP (Internet Control Message Protocol) is used for network troubleshooting and error reporting, OSPF (Open Shortest Path First) is a routing protocol, and BGP (Border Gateway Protocol) is used for routing between autonomous systems.\nData Link Layer: Ethernet is a widely used protocol for local area networks (LANs), Wi-Fi is used for wireless communication, PPP (Point-to-Point Protocol) is used for point-to-point connections, HDLC (High-Level Data Link Control) is a synchronous data link protocol, and MAC (Media Access Control) addresses are unique identifiers for network interfaces.\nPhysical Layer: This layer deals with the physical transmission of data and includes technologies like Ethernet cables, fiber optic cables, and radio waves for wireless communication.\nThe OSI model provides a layered approach to network communication, where each layer performs specific functions and interacts with adjacent layers to facilitate data transmission across networks. |\n",
    "description": "",
    "tags": null,
    "title": "Networking - OSI Model",
    "uri": "/basics-of-networking/osi_model/index.html"
  },
  {
    "content": "To get your AWS Access Key ID and AWS Secret Access Key, you can follow these steps:\nSign in to the AWS Management Console: Open your web browser and go to the AWS Management Console at https://console.aws.amazon.com/. Sign in using your AWS account credentials.\nOpen the IAM service: Once you are logged in to the AWS Management Console, search for “IAM” (Identity and Access Management) in the services search bar, and click on the IAM service to open it.\nAccess the Users section: In the IAM console, locate the “Users” option in the left navigation pane and click on it. This will show you a list of IAM users in your AWS account.\nCreate a new IAM user (optional): If you don’t have an existing IAM user with the necessary permissions, you can create a new IAM user by clicking on the “Add user” button. Follow the instructions to provide a username and set the access type.\nGenerate access keys: In the list of IAM users, locate the user for which you want to generate the access keys and click on the username to access the user’s details.\nAccess the Security Credentials tab: Within the user’s details, navigate to the “Security credentials” tab, which provides access to the user’s security-related settings.\nCreate access keys: Under the “Access keys” section, click on the “Create access key” button. This will generate a new access key pair for the selected IAM user.\nCopy the Access Key ID and Secret Access Key: Once the access keys are generated, you will see the Access Key ID and Secret Access Key on the screen. Copy these values or download the CSV file that contains the access key details.\nImportant: The Secret Access Key is only displayed once when the keys are first generated. Make sure to securely store the Secret Access Key in a safe location. If you lose it, you will need to generate a new access key pair.\nThat’s it! You now have your AWS Access Key ID and AWS Secret Access Key. These credentials are essential for configuring AWS CLI or any other AWS service that requires access to your AWS account.\n",
    "description": "",
    "tags": null,
    "title": "Get Access Key and Secret Access Key",
    "uri": "/aws/iam/iam_keys/index.html"
  },
  {
    "content": "Terrafom Features This section covers: - IAM\n",
    "description": "",
    "tags": null,
    "title": "IAM - Administration",
    "uri": "/aws/iam/index.html"
  },
  {
    "content": "TCP/IP Model The TCP/IP (Transmission Control Protocol/Internet Protocol) model is a conceptual framework used to describe the protocols and communication process used on the internet. It is a suite of protocols that define how data is transmitted, routed, and received over the internet. The TCP/IP model consists of four interconnected layers, each responsible for specific tasks:\nLayer Function Protocols/Examples Application Layer Provides network services directly to end-user applications. HTTP, FTP, DNS, SMTP, Telnet Transport Layer Ensures reliable end-to-end delivery of data between applications. TCP, UDP Internet Layer Handles addressing, routing, and fragmentation of data packets across networks. IP (IPv4, IPv6), ICMP, IGMP, ARP Network Interface Layer Transmits data between devices on the same network and provides access to the physical network medium. Ethernet, Wi-Fi, DSL, ATM, Token Ring Now, let’s provide examples for each layer:\nApplication Layer: HTTP (Hypertext Transfer Protocol) is used for web browsing, FTP (File Transfer Protocol) is used for file transfer, DNS (Domain Name System) is used for domain name resolution, and Telnet is used for remote login.\nTransport Layer: TCP (Transmission Control Protocol) provides reliable and ordered delivery of data, ensuring error-free communication between applications. UDP (User Datagram Protocol) provides faster, connectionless communication but does not guarantee reliability.\nInternet Layer: IP (Internet Protocol) is responsible for addressing and routing packets across networks. ICMP (Internet Control Message Protocol) handles network error reporting, while IGMP (Internet Group Management Protocol) manages multicast group memberships. ARP (Address Resolution Protocol) maps IP addresses to MAC addresses.\nNetwork Interface Layer: This layer deals with the physical transmission of data and includes technologies like Ethernet, Wi-Fi, DSL, ATM, and Token Ring, which provide access to the physical network medium.\nThe TCP/IP model is the foundation of modern internet communication, with each layer performing specific functions to enable reliable and efficient data transmission across networks.\n",
    "description": "",
    "tags": null,
    "title": "TCP/IP Model ",
    "uri": "/basics-of-networking/tcp_ip/index.html"
  },
  {
    "content": " Command Description Example(s) ls List directory contents ls cd Change directory cd /var/log pwd Print working directory pwd mkdir Create a directory mkdir mydir rm Remove files or directories rm myfile.txt cp Copy files and directories cp file1.txt file2.txt mv Move or rename files and directories mv oldname.txt newname.txt touch Create an empty file touch myfile.txt cat Concatenate and display file content cat myfile.txt grep Search for patterns in files grep “pattern” myfile.txt find Search for files and directories find /home -name “file.txt” chmod Change file permissions chmod 644 myfile.txt chown Change file owner and group chown user:group myfile.txt tar Archive files into a tarball tar -cvf archive.tar file1.txt file2.txt gzip Compress files using gzip gzip myfile.txt unzip Extract files from a zip archive unzip archive.zip ssh Securely connect to a remote server via SSH ssh username@remotehost scp Securely copy files between local and remote hosts scp myfile.txt username@remotehost:/path/to/dest systemctl Control system services systemctl start apache top Display system resource usage top ps Display running processes ps aux kill Terminate a process kill PID df Display disk space usage df -h du Estimate file and directory space usage du -sh mydir ifconfig (or ip) View and configure network interfaces ifconfig ping Send ICMP echo requests to a host ping google.com wget Download files from the internet wget https://example.com/file.txt history View command history history man Display the manual page for a command man ls Please note that these examples provide a basic understanding of each command. Each command has various options and additional use cases, which can be explored by referring to the command’s manual page (e.g., man ls for detailed information on the ls command and its options).\n",
    "description": "",
    "tags": null,
    "title": "Linux Basic Commands",
    "uri": "/linux/linux_basic_commands/index.html"
  },
  {
    "content": " Command Description Example(s) ls List directory contents ls cd Change directory cd /var/log pwd Print working directory pwd mkdir Create a directory mkdir mydir rm Remove files or directories rm myfile.txt cp Copy files and directories cp file1.txt file2.txt mv Move or rename files and directories mv oldname.txt newname.txt touch Create an empty file touch myfile.txt cat Concatenate and display file content cat myfile.txt grep Search for patterns in files grep “pattern” myfile.txt find Search for files and directories find /home -name “file.txt” chmod Change file permissions chmod 644 myfile.txt chown Change file owner and group chown user:group myfile.txt tar Archive files into a tarball tar -cvf archive.tar file1.txt file2.txt gzip Compress files using gzip gzip myfile.txt unzip Extract files from a zip archive unzip archive.zip ssh Securely connect to a remote server via SSH ssh username@remotehost scp Securely copy files between local and remote hosts scp myfile.txt username@remotehost:/path/to/dest systemctl Control system services systemctl start apache top Display system resource usage top ps Display running processes ps aux kill Terminate a process kill PID df Display disk space usage df -h du Estimate file and directory space usage du -sh mydir ifconfig (or ip) View and configure network interfaces ifconfig ping Send ICMP echo requests to a host ping google.com wget Download files from the internet wget https://example.com/file.txt history View command history history man Display the manual page for a command man ls Please note that these examples provide a basic understanding of each command. Each command has various options and additional use cases, which can be explored by referring to the command’s manual page (e.g., man ls for detailed information on the ls command and its options).\n",
    "description": "",
    "tags": null,
    "title": "Linux Basic Commands",
    "uri": "/maven/maven_intro/index.html"
  },
  {
    "content": "Here’s a table comparing the main differences between TCP (Transmission Control Protocol) and UDP (User Datagram Protocol):\nFeature TCP UDP Connection-oriented or Connectionless Connection-oriented Connectionless Reliability Reliable data delivery with acknowledgments and retransmissions Unreliable data delivery without acknowledgments or retransmissions Ordering Guarantees ordered delivery of data Does not guarantee ordered delivery of data Error Checking Performs error checking using checksums No error checking mechanism Flow Control Implements flow control to prevent overwhelming the receiver No flow control mechanism Congestion Control Implements congestion control to avoid network congestion No congestion control mechanism Overhead Higher overhead due to additional control mechanisms Lower overhead due to minimal control mechanisms Example Applications Web browsing, email, file transfer Streaming media, online gaming, DNS requests The table highlights the key differences between TCP and UDP in terms of their connection-oriented/connectionless nature, reliability, ordering, error checking, flow control, congestion control, overhead, and example applications. Understanding these differences is essential for selecting the appropriate protocol based on the specific requirements of the network application.\n",
    "description": "",
    "tags": null,
    "title": "TCP Vs UDP ",
    "uri": "/basics-of-networking/diff_tcp_vs_udp/index.html"
  },
  {
    "content": "A DNS (Domain Name System) server is a crucial component of the internet infrastructure that translates domain names into IP addresses. It acts as a directory or a phonebook for the internet, allowing users to access websites using human-readable domain names rather than numerical IP addresses.\nWhen you enter a domain name in a web browser, such as www.example.com, the DNS server is responsible for converting that domain name into the corresponding IP address, such as 192.0.2.1. This translation process is essential for establishing a connection with the desired website or online service.\nHere’s a simplified explanation of how a DNS server works:\nDNS Resolution Request: When you enter a domain name in your web browser, your computer sends a DNS resolution request to a DNS server. This request contains the domain name you want to access.\nRecursive DNS Server: The DNS server receiving the request might be a recursive DNS server, which acts as an intermediary between your computer and other DNS servers. It performs the necessary steps to resolve the domain name.\nDNS Caching: The recursive DNS server first checks if it has the IP address corresponding to the requested domain name stored in its cache. DNS caching helps improve efficiency by storing previously resolved domain names and their IP addresses. If the IP address is found in the cache, the recursive DNS server retrieves it and returns it to your computer.\nIterative Query: If the IP address is not found in the cache, the recursive DNS server initiates an iterative query process. It starts by contacting the root DNS servers to find the authoritative DNS server responsible for the top-level domain (TLD) of the requested domain name (e.g., .com, .org).\nAuthority Resolution: The root DNS server directs the recursive DNS server to the appropriate TLD DNS server. The recursive DNS server then contacts the TLD DNS server to obtain the IP address of the authoritative DNS server for the specific domain name.\nFinal Resolution: The recursive DNS server communicates with the authoritative DNS server, which stores the IP address information for the requested domain name. The authoritative DNS server responds with the IP address.\nResponse to Client: The recursive DNS server receives the IP address from the authoritative DNS server and sends it back to your computer. Your computer can then establish a connection to the website using the obtained IP address.\nOverall, a DNS server plays a vital role in translating domain names into IP addresses, enabling seamless navigation and communication on the internet. It helps users access websites and online services by providing the necessary address resolution services.\nHere’s a simple diagram illustrating the flow of a DNS request from a user to a DNS server:\n+-------------------+ | User's | | Computer | +-------------------+ | | (1) DNS request | v +-------------------+ | DNS Server | +-------------------+ | | (2) DNS resolution request | v +-------------------+ | Root DNS | | Server | +-------------------+ | | (3) Redirect to TLD DNS server | v +-------------------+ | TLD DNS | | Server | +-------------------+ | | (4) Redirect to Authoritative DNS server | v +-------------------+ | Authoritative | | DNS Server | +-------------------+ | | (5) DNS resolution response | v +-------------------+ | DNS Server | +-------------------+ | | (6) IP address response | v +-------------------+ | User's | | Computer | +-------------------+ In this diagram, the DNS request starts from the user’s computer, goes through a DNS server, and follows the hierarchy of DNS servers until it reaches the authoritative DNS server for the specific domain. The authoritative DNS server then responds with the IP address, which is sent back to the user’s computer, allowing it to establish a connection with the desired website.\nPlease note that this is a simplified representation, and in reality, there can be multiple levels of DNS servers involved in the resolution process.\n",
    "description": "",
    "tags": null,
    "title": "DNS Server ",
    "uri": "/basics-of-networking/dns_server/index.html"
  },
  {
    "content": "CodvaTech Labs DevOps BootCamp This documentation is designed for CodvaTech Labs DevOps BootCamp Course\nDevOps Tech Stack DevOps BootCamp will be covering below Tech Stack\nNetworking Core Concepets Linux Training AWS Core Services Basics of GIT and Github Infra As Code - Terraform Configuration Management - Ansible Jenkins Setup CI/CD Pipeline for Legacy tech stack using Jenkins , Ansible , Maven Basics of Docker AWS ECS Solution Setup CI/CD Piepline for Container based tech stack Coming Soon We are working on adding below tech stack in our DevOps course\nBasics of Azure Basics of Kubernates Contributors This documentation was made possible due to many contributions from the CodvaTech Labs\nA big shout out to CodvaTech Labs Team\nContributors \u0026 Reviewers\nNilesh G Mohan G ",
    "description": "",
    "tags": null,
    "title": "CodvaTechLabs DevOps BootCamp",
    "uri": "/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Linuxes",
    "uri": "/linux/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Mavens",
    "uri": "/maven/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
